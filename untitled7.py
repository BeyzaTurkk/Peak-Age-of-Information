# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x4bTW1Ur4E3Ck6LlRmDTfm8h2SczxazU
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from itertools import product
from collections import defaultdict



#  Peak AoI WITHOUT interventions
def bellman_minimize_peak_aoi(N, M, p):
    V = np.full((N+1, M+1, N+1, N+1), np.inf)
    policy = np.zeros((N, M+1, N+1, N+1), dtype=np.uint8)

    for m in range(M+1):
        for a in range(N+1):
            for b in range(N+1):
                if b >= a:
                    V[N, m, a, b] = b

    # Backward DP
    for n in range(N-1, -1, -1):
        for m in range(M+1):
            for a in range(N+1):
                for b in range(N+1):
                    if b < a:
                        continue

                    # Action 0: stay silent
                    new_a = min(a + 1, N)
                    new_b = max(b, new_a)
                    wait_cost = V[n+1, m, new_a, new_b]
                    best_cost = wait_cost
                    best_action = 0

                    # Action 1: transmit (if we have budget)
                    if m > 0:
                        succ_cost = V[n+1, m-1, 0, b]  # AoI reset to 0, peak unchanged
                        fail_a = min(a + 1, N)
                        fail_b = max(b, fail_a)
                        fail_cost = V[n+1, m-1, fail_a, fail_b]
                        trans_cost = p * succ_cost + (1 - p) * fail_cost

                        if trans_cost < best_cost:
                            best_cost = trans_cost
                            best_action = 1

                    V[n, m, a, b] = best_cost
                    policy[n, m, a, b] = best_action

    return V, policy


# Peak AoI WITH interventions
def bellman_minimize_peak_with_external(N, M, p=1.0, alpha=0.05):
    V = np.full((N+1, M+1, N+1, N+1), np.inf)
    policy = np.zeros((N, M+1, N+1, N+1), dtype=np.uint8)

    # Terminal condition remains the same
    for m in range(M+1):
        for a in range(N+1):
            for b in range(N+1):
                if b >= a:
                    V[N, m, a, b] = b

    # Backward DP
    for n in range(N-1, -1, -1):
        for m in range(M+1):
            for a in range(N+1):
                for b in range(N+1):
                    if b < a:
                        continue

                    # Action 0: stay silent (subject to external reset with prob alpha)
                    reset_a = 0
                    reset_b = max(b, reset_a)
                    reset_cost = V[n+1, m, reset_a, reset_b]

                    no_reset_a = min(a + 1, N)
                    no_reset_b = max(b, no_reset_a)
                    no_reset_cost = V[n+1, m, no_reset_a, no_reset_b]


                    silent_cost = alpha * reset_cost + (1 - alpha) * no_reset_cost
                    best_cost = silent_cost
                    best_action = 0

                    # Action 1: transmit (if we have budget)
                    if m > 0:

                        succ_reset_a = 0
                        succ_reset_b = max(b, succ_reset_a)
                        succ_reset_cost = V[n+1, m-1, succ_reset_a, succ_reset_b]

                        succ_no_reset_a = 0  # Successful transmission resets AoI to 0
                        succ_no_reset_b = max(b, succ_no_reset_a)
                        succ_no_reset_cost = V[n+1, m-1, succ_no_reset_a, succ_no_reset_b]

                        succ_cost = alpha * succ_reset_cost + (1 - alpha) * succ_no_reset_cost

                        # For failed transmission
                        fail_reset_a = 0
                        fail_reset_b = max(b, fail_reset_a)
                        fail_reset_cost = V[n+1, m-1, fail_reset_a, fail_reset_b]

                        fail_no_reset_a = min(a + 1, N)
                        fail_no_reset_b = max(b, fail_no_reset_a)
                        fail_no_reset_cost = V[n+1, m-1, fail_no_reset_a, fail_no_reset_b]

                        fail_cost = alpha * fail_reset_cost + (1 - alpha) * fail_no_reset_cost

                        trans_cost = p * succ_cost + (1 - p) * fail_cost

                        if trans_cost < best_cost:
                            best_cost = trans_cost
                            best_action = 1

                    V[n, m, a, b] = best_cost
                    policy[n, m, a, b] = best_action

    return V, policy

def simulate_episode(N, M, p, policy, alpha=0.0, seed=None):
    rng = np.random.default_rng(seed)

    a = 0
    b = 0
    m = M

    b_traj = np.empty(N+1, dtype=np.int32)
    b_traj[0] = b

    for n in range(N):
        a_clamped = min(a, N)
        b_clamped = min(b, N)
        act = int(policy[n, m, a_clamped, b_clamped])  # 0: silent, 1: transmit

        if act == 1 and m > 0:
            # Transmit
            success = rng.random() < p
            if success:
                a = 0
            else:
                a = min(a + 1, N)
            m -= 1
        else:
            # Stay silent
            if alpha > 0.0 and (rng.random() < alpha):
                a = 0  # external reset
            else:
                a = min(a + 1, N)

        b = max(b, a)
        b_traj[n+1] = b

    return b_traj


def simulate_many(N, M, p, policy, alpha=0.0, num_runs=1000, seed=42):
    rng = np.random.default_rng(seed)
    seeds = rng.integers(0, 2**31-1, size=num_runs, endpoint=False)

    peaks_over_time = np.empty((num_runs, N+1), dtype=np.int32)
    for i in range(num_runs):
        peaks_over_time[i] = simulate_episode(N, M, p, policy, alpha=alpha, seed=int(seeds[i]))

    final_peaks = peaks_over_time[:, -1]
    mean_peak_time_series = peaks_over_time.mean(axis=0)
    return peaks_over_time, final_peaks, mean_peak_time_series

def correlated_channel_generator(p_good, p_bad, q, r, seed=None):
    # P(0->1)=q, P(1->0)=r
    rng = np.random.default_rng(seed)
    state = 0  # start in GOOD
    def p_t():
        nonlocal state
        p = p_good if state == 0 else p_bad
        if state == 0:
            if rng.random() < q:
                state = 1
        else:
            if rng.random() < r:
                state = 0
        return p
    return p_t

def iid_channel_generator(p, seed=None):
    def p_t():
        return p
    return p_t

def simulate_episode_with_channel(N, M, policy, p_process, alpha=0.0, seed=None):
    rng = np.random.default_rng(seed)
    a, b, m = 0, 0, M
    b_traj = np.empty(N+1, dtype=np.int32)
    b_traj[0] = b

    for n in range(N):
        a_c = min(a, N)
        b_c = min(b, N)
        act = int(policy[n, m, a_c, b_c])

        if act == 1 and m > 0:
            p_now = p_process()
            success = rng.random() < p_now
            if success:
                a = 0
            else:
                a = min(a + 1, N)
            m -= 1
        else:
            if alpha > 0.0 and (rng.random() < alpha):
                a = 0
            else:
                a = min(a + 1, N)

        b = max(b, a)
        b_traj[n+1] = b

    return b_traj

def simulate_many_with_channel(N, M, policy, p_process_factory, alpha=0.0, num_runs=1000, seed=42):
    rng = np.random.default_rng(seed)
    run_seeds = rng.integers(0, 2**31-1, size=num_runs, endpoint=False)

    peaks_over_time = np.empty((num_runs, N+1), dtype=np.int32)
    for i, s in enumerate(run_seeds):
        p_proc = p_process_factory(int(s))
        peaks_over_time[i] = simulate_episode_with_channel(N, M, policy, p_proc, alpha=alpha, seed=int(s))

    final_peaks = peaks_over_time[:, -1]
    mean_peak_time_series = peaks_over_time.mean(axis=0)
    return final_peaks, mean_peak_time_series

def alpha_from_K(K, N):
    return float(np.clip(K / max(N, 1), 0.0, 1.0))

def set_paper_style():
    plt.rcParams.update({
        "figure.dpi": 100,
        "font.size": 12,
        "axes.labelsize": 12,
        "axes.titlesize": 13,
        "legend.fontsize": 11,
        "xtick.labelsize": 11,
        "ytick.labelsize": 11,
        "lines.linewidth": 2.0,
        "lines.markersize": 6,
        "grid.alpha": 0.35
    })

set_paper_style()

# 1) Correlated channel: Peak AoI (normalized) vs Burst, curves for different K
def plot_correlated_resets_vs_burst(
    N=100, M=4, epsilon=0.2,
    K_list=(0, 2, 5, 10),
    burst_list=(1, 2, 4, 8, 16),
    num_runs=1000, seed=1234
):

    # policy from mean success prob
    p_bar = 1.0 - float(epsilon)
    _, policy = bellman_minimize_peak_aoi(N, M, p_bar)

    plt.figure(figsize=(6.4, 4.6))
    for K in K_list:
        alpha = alpha_from_K(K, N)
        y_vals = []
        for B in burst_list:
            r = 1.0 / float(B) if B > 0 else 1.0
            if epsilon >= 1.0:
                q = 1.0
            else:
                q = float(epsilon) * r / max(1e-12, (1.0 - float(epsilon)))

            def factory(run_seed):
                return correlated_channel_generator(
                    p_good=1.0, p_bad=0.0, q=q, r=r, seed=run_seed
                )

            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory, alpha=alpha,
                num_runs=num_runs, seed=seed + int(B*100 + K)
            )
            y_vals.append(np.mean(finals) / N)

        plt.plot(burst_list, y_vals, marker="o", label=f"K={K}")

    plt.xlabel("Burst length B (expected bad run)")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Random Resets on Correlated Channel (M={M}, Îµ={epsilon})")
    plt.legend(title="Resets", ncols=2)
    plt.tight_layout()
    plt.show()

def plot_iid_resets_vs_epsilon(
    N=100, M=4,
    eps_list=np.linspace(0.0, 0.4, 9),
    K_list=(0, 2, 5, 10),
    num_runs=1000, seed=2025
):

    plt.figure(figsize=(6.4, 4.6))
    for K in K_list:
        alpha = alpha_from_K(K, N)
        y_vals = []
        for eps in eps_list:
            p = 1.0 - float(eps)
            _, policy = bellman_minimize_peak_aoi(N, M, p)

            def factory(run_seed):
                return iid_channel_generator(p, seed=run_seed)

            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory, alpha=alpha,
                num_runs=num_runs, seed=seed + int(1000*eps + K)
            )
            y_vals.append(np.mean(finals) / N)

        plt.plot(eps_list, y_vals, marker="s", label=f"K={K}")

    plt.xlabel("Packet error rate $\\varepsilon$  (IID)")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Random Resets on IID Channels (M={M})")
    plt.legend(title="Resets", ncols=2)
    plt.tight_layout()
    plt.show()

def plot_tradeoff_K_vs_M_isopeak(
    N=100,
    M_values=(1,2,3,4,5,6,8,10,12),
    K_values=(0,1,2,3,4,5,6,8,10,12),
    p=1.0,
    levels_norm=(0.10, 0.20, 0.30),
    num_runs=1000, seed=7
):

    def factory(run_seed):
        return iid_channel_generator(p, seed=run_seed)

    policies = {}
    for M in M_values:
        _, pol = bellman_minimize_peak_aoi(N, M, p)
        policies[M] = pol

    Ms = np.array(M_values, dtype=float)
    Ks = np.array(K_values, dtype=float)
    Z = np.zeros((len(Ks), len(Ms)), dtype=float)

    for j, M in enumerate(M_values):
        policy = policies[M]
        for i, K in enumerate(K_values):
            alpha = alpha_from_K(K, N)
            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory,
                alpha=alpha, num_runs=num_runs, seed=seed + 1000*j + i
            )
            Z[i, j] = np.mean(finals) / N

    fig, ax = plt.subplots(figsize=(6.6, 4.8))
    CS = ax.contour(Ms, Ks, Z, levels=levels_norm, linewidths=2.2)
    ax.clabel(CS, inline=True, fontsize=10, fmt="%.2f")
    ax.set_xlabel("Transmission budget $M$")
    ax.set_ylabel("Resets $K$")
    ax.set_title(f"Iso-Peak-AoI Curves,  $\\mathbb{{E}}[b_N]/N$  (p={p})")
    ax.grid(True)
    fig.tight_layout()
    plt.show()

# 4) Peak AoI vs K (normalized), fixed (M, channel)
def plot_peak_vs_K(
    N=100, M=4, p=1.0,
    K_values=tuple(range(0, 21, 2)),
    num_runs=1000, seed=2026
):
    _, policy = bellman_minimize_peak_aoi(N, M, p)

    y_vals = []
    for K in K_values:
        alpha = alpha_from_K(K, N)
        def factory(run_seed):
            return iid_channel_generator(p, seed=run_seed)
        finals, _ = simulate_many_with_channel(
            N, M, policy, p_process_factory=factory,
            alpha=alpha, num_runs=num_runs, seed=seed + K
        )
        y_vals.append(np.mean(finals) / N)

    plt.figure(figsize=(6.4, 4.6))
    plt.plot(K_values, y_vals, marker="o")
    plt.xlabel("Resets $K$")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Effect of Random Resets on Peak AoI (M={M}, p={p})")
    plt.tight_layout()
    plt.show()

def extra_figures_main():
    N = 100
    M = 4
    num_runs = 1000

    plot_correlated_resets_vs_burst(
        N=N, M=M, epsilon=0.2,
        K_list=(0, 2, 5, 10),
        burst_list=(1, 2, 4, 8, 16, 32),
        num_runs=num_runs, seed=111
    )

    plot_iid_resets_vs_epsilon(
        N=N, M=M,
        eps_list=np.linspace(0.0, 0.4, 9),
        K_list=(0, 2, 5, 10),
        num_runs=num_runs, seed=222
    )

    plot_tradeoff_K_vs_M_isopeak(
        N=N,
        M_values=(1,2,3,4,5,6,8,10,12,16),
        K_values=(0,1,2,3,4,5,6,8,10,12,16,20),
        p=1.0,
        levels_norm=(0.10, 0.20, 0.30, 0.40),
        num_runs=num_runs, seed=333
    )

    plot_peak_vs_K(
        N=N, M=M, p=1.0,
        K_values=tuple(range(0, 21, 2)),
        num_runs=num_runs, seed=444
    )


if __name__ == "__main__":
    extra_figures_main()

# 1) Correlated channel: Peak AoI (normalized) vs Burst, curves for different K
def plot_correlated_resets_vs_burst(
    N=100, M=4, epsilon=0.2,
    K_list=(0, 2, 5, 10),
    burst_list=(1, 2, 4, 8, 16),
    num_runs=1000, seed=1234
):
    # GilbertâElliott with p_good=1, p_bad=0.
    #  Îµ = q/(q+r) Burst Bâ1/r => r=1/B, q = Îµ r / (1-Îµ).

    plt.figure(figsize=(6.4, 4.6))
    for K in K_list:
        alpha = alpha_from_K(K, N)
        y_vals = []
        for B in burst_list:
            r = 1.0 / float(B) if B > 0 else 1.0
            if epsilon >= 1.0:
                q = 1.0
            else:
                q = float(epsilon) * r / max(1e-12, (1.0 - float(epsilon)))


            _, policy = bellman_minimize_peak_with_external(N, M, p=1.0-epsilon, alpha=alpha)

            def factory(run_seed):
                return correlated_channel_generator(
                    p_good=1.0, p_bad=0.0, q=q, r=r, seed=run_seed
                )

            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory, alpha=alpha,
                num_runs=num_runs, seed=seed + int(B*100 + K)
            )
            y_vals.append(np.mean(finals) / N)

        plt.plot(burst_list, y_vals, marker="o", label=f"K={K}")

    plt.xlabel("Burst length B (expected bad run)")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Random Resets on Correlated Channel (M={M}, Îµ={epsilon})")
    plt.legend(title="Resets", ncols=2)
    plt.tight_layout()
    plt.show()

# 2) IID channel: Peak AoI (normalized) vs Îµ (PER), curves for different K
def plot_iid_resets_vs_epsilon(
    N=100, M=4,
    eps_list=np.linspace(0.0, 0.4, 9),
    K_list=(0, 2, 5, 10),
    num_runs=1000, seed=2025
):
    plt.figure(figsize=(6.4, 4.6))
    for K in K_list:
        alpha = alpha_from_K(K, N)
        y_vals = []
        for eps in eps_list:
            p = 1.0 - float(eps)

            _, policy = bellman_minimize_peak_with_external(N, M, p, alpha)

            def factory(run_seed):
                return iid_channel_generator(p, seed=run_seed)

            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory, alpha=alpha,
                num_runs=num_runs, seed=seed + int(1000*eps + K)
            )
            y_vals.append(np.mean(finals) / N)

        plt.plot(eps_list, y_vals, marker="s", label=f"K={K}")

    plt.xlabel("Packet error rate $\\varepsilon$  (IID)")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Random Resets on IID Channels (M={M})")
    plt.legend(title="Resets", ncols=2)
    plt.tight_layout()
    plt.show()

# 3) Trade-off: x-axis M, y-axis K, iso-peak lines
def plot_tradeoff_K_vs_M_isopeak(
    N=100,
    M_values=(1,2,3,4,5,6,8,10,12),
    K_values=(0,1,2,3,4,5,6,8,10,12),
    p=1.0,
    levels_norm=(0.10, 0.20, 0.30),
    num_runs=1000, seed=7
):
    def factory(run_seed):
        return iid_channel_generator(p, seed=run_seed)

    policies = {}
    for M in M_values:
        for K in K_values:
            alpha = alpha_from_K(K, N)

            _, pol = bellman_minimize_peak_with_external(N, M, p, alpha)
            policies[(M, K)] = pol

    Ms = np.array(M_values, dtype=float)
    Ks = np.array(K_values, dtype=float)
    Z = np.zeros((len(Ks), len(Ms)), dtype=float)

    for j, M in enumerate(M_values):
        for i, K in enumerate(K_values):
            alpha = alpha_from_K(K, N)
            policy = policies[(M, K)]
            finals, _ = simulate_many_with_channel(
                N, M, policy, p_process_factory=factory,
                alpha=alpha, num_runs=num_runs, seed=seed + 1000*j + i
            )
            Z[i, j] = np.mean(finals) / N

    fig, ax = plt.subplots(figsize=(6.6, 4.8))
    CS = ax.contour(Ms, Ks, Z, levels=levels_norm, linewidths=2.2)
    ax.clabel(CS, inline=True, fontsize=10, fmt="%.2f")
    ax.set_xlabel("Transmission budget $M$")
    ax.set_ylabel("Resets $K$")
    ax.set_title(f"Iso-Peak-AoI Curves,  $\\mathbb{{E}}[b_N]/N$  (p={p})")
    ax.grid(True)
    fig.tight_layout()
    plt.show()

# 4) Peak AoI vs K (normalized), fixed (M, channel)
def plot_peak_vs_K(
    N=100, M=4, p=1.0,
    K_values=tuple(range(0, 21, 2)),
    num_runs=1000, seed=2026
):
    y_vals = []
    for K in K_values:
        alpha = alpha_from_K(K, N)
        _, policy = bellman_minimize_peak_with_external(N, M, p, alpha)

        def factory(run_seed):
            return iid_channel_generator(p, seed=run_seed)

        finals, _ = simulate_many_with_channel(
            N, M, policy, p_process_factory=factory,
            alpha=alpha, num_runs=num_runs, seed=seed + K
        )
        y_vals.append(np.mean(finals) / N)

    plt.figure(figsize=(6.4, 4.6))
    plt.plot(K_values, y_vals, marker="o")
    plt.xlabel("Resets $K$")
    plt.ylabel("Normalized final Peak AoI  $\\mathbb{E}[b_N]/N$")
    plt.ylim(bottom=0)
    plt.grid(True)
    plt.title(f"Effect of Random Resets on Peak AoI (M={M}, p={p})")
    plt.tight_layout()
    plt.show()

def extra_figures_main():
    N = 100
    M = 4
    num_runs = 1000

    plot_correlated_resets_vs_burst(
        N=N, M=M, epsilon=0.2,
        K_list=(0, 2, 5, 10),
        burst_list=(1, 2, 4, 8, 16, 32),
        num_runs=num_runs, seed=111
    )

    plot_iid_resets_vs_epsilon(
        N=N, M=M,
        eps_list=np.linspace(0.0, 0.4, 9),
        K_list=(0, 2, 5, 10),
        num_runs=num_runs, seed=222
    )

    plot_tradeoff_K_vs_M_isopeak(
        N=N,
        M_values=(1,2,3,4,5,6,8,10,12,16),
        K_values=(0,1,2,3,4,5,6,8,10,12,16,20),
        p=1.0,
        levels_norm=(0.10, 0.20, 0.30, 0.40),
        num_runs=num_runs, seed=333
    )

    plot_peak_vs_K(
        N=N, M=M, p=1.0,
        K_values=tuple(range(0, 21, 2)),
        num_runs=num_runs, seed=444
    )

if __name__ == "__main__":
    extra_figures_main()